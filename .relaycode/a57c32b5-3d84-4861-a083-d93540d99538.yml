uuid: a57c32b5-3d84-4861-a083-d93540d99538
projectId: relaycode
createdAt: '2025-06-24T02:34:09.756Z'
gitCommitMsg: 'refactor: Organize config into nested objects'
promptSummary: >-
  Refactor relaycode.config.json to categorize properties into logical objects
  for better organization. Update all related code to use the new structure.
reasoning:
  - >-
    I've refactored the `relaycode.config.json` file to categorize settings into
    logical groups: `core`, `watcher`, `patch`, and `git`. This makes the
    configuration cleaner and easier to manage. I've updated all the necessary
    code to reflect this new structure, including the Zod schema for validation,
    the `init` command's help message, and all parts of the application that
    access configuration values.
  - 'Here are the changes:'
  - >-
    I will start by updating the `relaycode.config.json` to its new, organized
    structure.
  - >-
    Next, I'll update the configuration schema in `src/types.ts` to match the
    new structure. This involves creating separate schemas for each category.
  - >-
    The `createConfig` function in `src/core/config.ts` can now be simplified,
    as the detailed schema will handle default values for the new nested
    objects.
  - >-
    I'll update the welcome message in `src/commands/init.ts` to guide users on
    the new configuration structure.
  - >-
    Now, I'll update the files that consume the configuration values, starting
    with `src/commands/apply.ts`.
  - >-
    The `watch` command uses several configuration properties, so I'll update
    them accordingly in `src/commands/watch.ts`.
  - >-
    Finally, I'll update `src/core/transaction.ts`, which orchestrates patch
    processing and uses many configuration values.
  - >-
    These changes improve the structure and maintainability of the configuration
    handling within the application.
operations:
  - type: write
    path: relaycode.config.json
    content: |-
      {
        "projectId": "relaycode",
        "core": {
          "logLevel": "info",
          "enableNotifications": true,
          "watchConfig": true
        },
        "watcher": {
          "clipboardPollInterval": 2000,
          "preferredStrategy": "auto"
        },
        "patch": {
          "approvalMode": "auto",
          "approvalOnErrorCount": 0,
          "linter": "bun tsc -b --noEmit",
          "preCommand": "",
          "postCommand": ""
        },
        "git": {
          "autoGitBranch": false,
          "gitBranchPrefix": "relay/",
          "gitBranchTemplate": "gitCommitMsg"
        }
      }
    patchStrategy: replace
  - type: write
    path: src/types.ts
    content: |-
      <<<<<<< SEARCH
      // Schema for relaycode.config.json
      export const ConfigSchema = z.object({
        projectId: z.string().min(1),
        logLevel: LogLevelNameSchema,
        clipboardPollInterval: z.number().int().positive().default(2000),
        approvalMode: z.enum(['auto', 'manual']).default('auto'),
        approvalOnErrorCount: z.number().int().min(0).default(0),
        linter: z.string().default('bun tsc --noEmit'),
        preCommand: z.string().default(''),
        postCommand: z.string().default(''),
        preferredStrategy: z.enum(['auto', 'replace', 'new-unified', 'multi-search-replace']).default('auto'),
        enableNotifications: z.boolean().default(true),
        autoGitBranch: z.boolean().default(false),
        gitBranchPrefix: z.string().default('relay/'),
        gitBranchTemplate: z.enum(['uuid', 'gitCommitMsg']).default('gitCommitMsg'),
        watchConfig: z.boolean().default(true),
      });
      export type Config = z.infer<typeof ConfigSchema>;
      =======
      // Schema for relaycode.config.json
      const CoreConfigSchema = z.object({
        logLevel: LogLevelNameSchema,
        enableNotifications: z.boolean().default(true),
        watchConfig: z.boolean().default(true),
      });

      const WatcherConfigSchema = z.object({
        clipboardPollInterval: z.number().int().positive().default(2000),
        preferredStrategy: z.enum(['auto', 'replace', 'new-unified', 'multi-search-replace']).default('auto'),
      });

      const PatchConfigSchema = z.object({
        approvalMode: z.enum(['auto', 'manual']).default('auto'),
        approvalOnErrorCount: z.number().int().min(0).default(0),
        linter: z.string().default('bun tsc --noEmit'),
        preCommand: z.string().default(''),
        postCommand: z.string().default(''),
      });

      const GitConfigSchema = z.object({
        autoGitBranch: z.boolean().default(false),
        gitBranchPrefix: z.string().default('relay/'),
        gitBranchTemplate: z.enum(['uuid', 'gitCommitMsg']).default('gitCommitMsg'),
      });

      export const ConfigSchema = z.object({
        projectId: z.string().min(1),
        core: CoreConfigSchema.default({}),
        watcher: WatcherConfigSchema.default({}),
        patch: PatchConfigSchema.default({}),
        git: GitConfigSchema.default({}),
      });
      export type Config = z.infer<typeof ConfigSchema>;
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/core/config.ts
    content: >-
      <<<<<<< SEARCH

      export const createConfig = async (projectId: string, cwd: string =
      process.cwd()): Promise<Config> => {
          const config = {
              projectId,
              clipboardPollInterval: 2000,
              approvalMode: 'auto' as const,
              approvalOnErrorCount: 0,
              linter: 'bun tsc --noEmit',
              preCommand: '',
              postCommand: '',
              preferredStrategy: 'auto' as const,
              enableNotifications: true,
          };
          
          // Ensure the schema defaults are applied, including for logLevel
          const validatedConfig = ConfigSchema.parse(config);

          const configPath = path.join(cwd, CONFIG_FILE_NAME);
          await fs.writeFile(configPath, JSON.stringify(validatedConfig, null, 2));

          return validatedConfig;
      };

      =======

      export const createConfig = async (projectId: string, cwd: string =
      process.cwd()): Promise<Config> => {
          const config = {
              projectId,
          };
          
          // Ensure the schema defaults are applied for nested objects
          const validatedConfig = ConfigSchema.parse(config);

          const configPath = path.join(cwd, CONFIG_FILE_NAME);
          await fs.writeFile(configPath, JSON.stringify(validatedConfig, null, 2));

          return validatedConfig;
      };

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/commands/init.ts
    content: >-
      <<<<<<< SEARCH

      const getInitMessage = (projectId: string): string => `

      ${chalk.green('✅ relaycode has been initialized for this project.')}


      Configuration file created: ${chalk.cyan(CONFIG_FILE_NAME)}


      Project ID: ${chalk.cyan(projectId)}


      ${chalk.bold('Next steps:')}

      ${chalk.gray('1.')} (Optional) Open ${chalk.cyan(CONFIG_FILE_NAME)} to
      customize settings like ${chalk.yellow("'preferredStrategy'")} to control
      how the AI generates code patches.
         - ${chalk.yellow("'auto'")} (default): The AI can choose the best patch strategy.
         - ${chalk.yellow("'new-unified'")}: Forces the AI to use diffs, great for most changes.
         - ${chalk.yellow("'replace'")}: Forces the AI to replace entire files, good for new files or small changes.
         - ${chalk.yellow("'multi-search-replace'")}: Forces the AI to perform precise search and replace operations.
         - For Git users, enable ${chalk.yellow("'autoGitBranch'")} to create a new branch for each transaction.

      ${chalk.gray('2.')} Run ${chalk.magenta("'relay watch'")} in your
      terminal. This will start the service and display the system prompt
      tailored to your configuration.


      ${chalk.gray('3.')} Copy the system prompt provided by
      ${chalk.magenta("'relay watch'")} and paste it into your AI assistant's
      "System Prompt" or "Custom Instructions".

      `;

      =======

      const getInitMessage = (projectId: string): string => `

      ${chalk.green('✅ relaycode has been initialized for this project.')}


      Configuration file created: ${chalk.cyan(CONFIG_FILE_NAME)}


      Project ID: ${chalk.cyan(projectId)}


      ${chalk.bold('Next steps:')}

      ${chalk.gray('1.')} (Optional) Open ${chalk.cyan(CONFIG_FILE_NAME)} to
      customize settings. The config is organized into sections:
         - In ${chalk.yellow("'watcher'")}, you can set ${chalk.yellow("'preferredStrategy'")} to control AI patch generation ('auto', 'new-unified', 'multi-search-replace', etc.).
         - In ${chalk.yellow("'git'")}, you can enable ${chalk.yellow("'git.autoGitBranch'")} to create a new branch for each transaction.
         - In ${chalk.yellow("'patch'")}, you can configure the linter, pre/post commands, and approval behavior.

      ${chalk.gray('2.')} Run ${chalk.magenta("'relay watch'")} in your
      terminal. This will start the service and display the system prompt
      tailored to your configuration.


      ${chalk.gray('3.')} Copy the system prompt provided by
      ${chalk.magenta("'relay watch'")} and paste it into your AI assistant's
      "System Prompt" or "Custom Instructions".

      `;

      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/commands/apply.ts
    content: >-
      <<<<<<< SEARCH

      export const applyCommand = async (filePath: string, cwd: string =
      process.cwd()): Promise<void> => {
          const config = await loadConfigOrExit(cwd);
          logger.setLevel(config.logLevel);
      =======

      export const applyCommand = async (filePath: string, cwd: string =
      process.cwd()): Promise<void> => {
          const config = await loadConfigOrExit(cwd);
          logger.setLevel(config.core.logLevel);
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/commands/watch.ts
    content: >-
      <<<<<<< SEARCH

      import { Config } from '../types';

      import fs from 'fs';

      import path from 'path';


      const getSystemPrompt = (projectId: string, preferredStrategy:
      Config['preferredStrategy']): string => {

      =======

      import { Config } from '../types';

      import fs from 'fs';

      import path from 'path';


      const getSystemPrompt = (projectId: string, preferredStrategy:
      Config['watcher']['preferredStrategy']): string => {

      >>>>>>> REPLACE

      <<<<<<< SEARCH
          const syntax = syntaxMap[preferredStrategy] ?? syntaxMap.auto;
          const strategyDetails = strategyDetailsMap[preferredStrategy] ?? strategyDetailsMap.auto;

          return [header, intro, syntax, strategyDetails, otherOps, finalSteps, footer].filter(Boolean).join('\n');
      }


      export const watchCommand = async (cwd: string = process.cwd()): Promise<{
      stop: () => void }> => {

      =======
          const syntax = syntaxMap[preferredStrategy] ?? syntaxMap.auto;
          const strategyDetails = strategyDetailsMap[preferredStrategy] ?? strategyDetailsMap.auto;

          return [header, intro, syntax, strategyDetails, otherOps, finalSteps, footer].filter(Boolean).join('\n');
      };


      export const watchCommand = async (cwd: string = process.cwd()): Promise<{
      stop: () => void }> => {

      >>>>>>> REPLACE

      <<<<<<< SEARCH
        const startServices = (config: Config) => {
          // Stop existing watcher if it's running
          if (clipboardWatcher) {
            clipboardWatcher.stop();
          }

          logger.setLevel(config.logLevel);
          logger.debug(`Log level set to: ${config.logLevel}`);
          logger.debug(`Preferred strategy set to: ${config.preferredStrategy}`);

          logger.log(getSystemPrompt(config.projectId, config.preferredStrategy));

          clipboardWatcher = createClipboardWatcher(config.clipboardPollInterval, async (content) => {
            logger.info('New clipboard content detected. Attempting to parse...');
      =======
        const startServices = (config: Config) => {
          // Stop existing watcher if it's running
          if (clipboardWatcher) {
            clipboardWatcher.stop();
          }

          logger.setLevel(config.core.logLevel);
          logger.debug(`Log level set to: ${config.core.logLevel}`);
          logger.debug(`Preferred strategy set to: ${config.watcher.preferredStrategy}`);

          logger.log(getSystemPrompt(config.projectId, config.watcher.preferredStrategy));

          clipboardWatcher = createClipboardWatcher(config.watcher.clipboardPollInterval, async (content) => {
            logger.info('New clipboard content detected. Attempting to parse...');
      >>>>>>> REPLACE

      <<<<<<< SEARCH
        // Initial startup
        const initialConfig = await loadConfigOrExit(cwd);
        logger.success('Configuration loaded. Starting relaycode watch...');
        startServices(initialConfig);

        // Watch for changes after initial setup
        if (initialConfig.watchConfig) {
          logger.info('Configuration file watching is enabled.');
          configWatcher = fs.watch(configPath, handleConfigChange);
        } else {
          logger.info('Configuration file watching is disabled. Changes to config will require a restart to take effect.');
        }
      =======
        // Initial startup
        const initialConfig = await loadConfigOrExit(cwd);
        logger.success('Configuration loaded. Starting relaycode watch...');
        startServices(initialConfig);

        // Watch for changes after initial setup
        if (initialConfig.core.watchConfig) {
          logger.info('Configuration file watching is enabled.');
          configWatcher = fs.watch(configPath, handleConfigChange);
        } else {
          logger.info('Configuration file watching is disabled. Changes to config will require a restart to take effect.');
        }
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
  - type: write
    path: src/core/transaction.ts
    content: |-
      <<<<<<< SEARCH
          // Notify if coming from watch mode, now that we know it's a new patch.
          if (notifyOnStart) {
              notifyPatchDetected(config.projectId, config.enableNotifications);
              logger.success(`Valid patch detected for project '${chalk.cyan(config.projectId)}'. Processing...`);
          }

          // 2. Pre-flight checks
          if (config.preCommand) {
              logger.log(`  - Running pre-command: ${chalk.magenta(config.preCommand)}`);
              const { exitCode, stderr } = await executeShellCommand(config.preCommand, cwd);
              if (exitCode !== 0) {
                  logger.error(`Pre-command failed with exit code ${chalk.red(exitCode)}, aborting transaction.`);
                  if (stderr) logger.error(`Stderr: ${stderr}`);
                  return;
              }
          }
      =======
          // Notify if coming from watch mode, now that we know it's a new patch.
          if (notifyOnStart) {
              notifyPatchDetected(config.projectId, config.core.enableNotifications);
              logger.success(`Valid patch detected for project '${chalk.cyan(config.projectId)}'. Processing...`);
          }

          // 2. Pre-flight checks
          if (config.patch.preCommand) {
              logger.log(`  - Running pre-command: ${chalk.magenta(config.patch.preCommand)}`);
              const { exitCode, stderr } = await executeShellCommand(config.patch.preCommand, cwd);
              if (exitCode !== 0) {
                  logger.error(`Pre-command failed with exit code ${chalk.red(exitCode)}, aborting transaction.`);
                  if (stderr) logger.error(`Stderr: ${stderr}`);
                  return;
              }
          }
      >>>>>>> REPLACE
      <<<<<<< SEARCH
              // Run post-command
              if (config.postCommand) {
                  logger.log(`  - Running post-command: ${chalk.magenta(config.postCommand)}`);
                  const postResult = await executeShellCommand(config.postCommand, cwd);
                  if (postResult.exitCode !== 0) {
                      logger.error(`Post-command failed with exit code ${chalk.red(postResult.exitCode)}.`);
                      if (postResult.stderr) logger.error(`Stderr: ${postResult.stderr}`);
                      throw new Error('Post-command failed, forcing rollback.');
                  }
              }
      =======
              // Run post-command
              if (config.patch.postCommand) {
                  logger.log(`  - Running post-command: ${chalk.magenta(config.patch.postCommand)}`);
                  const postResult = await executeShellCommand(config.patch.postCommand, cwd);
                  if (postResult.exitCode !== 0) {
                      logger.error(`Post-command failed with exit code ${chalk.red(postResult.exitCode)}.`);
                      if (postResult.stderr) logger.error(`Stderr: ${postResult.stderr}`);
                      throw new Error('Post-command failed, forcing rollback.');
                  }
              }
      >>>>>>> REPLACE
      <<<<<<< SEARCH
              // Check for approval
              const finalErrorCount = await getErrorCount(config.linter, cwd);
              logger.log(`  - Final linter error count: ${finalErrorCount > 0 ? chalk.red(finalErrorCount) : chalk.green(finalErrorCount)}`);
              
              let isApproved: boolean;
              if (config.approvalMode === 'auto') { // Auto mode allows conditional auto-approval
                  const canAutoApprove = finalErrorCount <= config.approvalOnErrorCount;

                  if (canAutoApprove) {
                      logger.success('  - Changes automatically approved based on your configuration.');
                      isApproved = true;
                  } else {
                      notifyApprovalRequired(config.projectId, config.enableNotifications);
                      isApproved = await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
                  }
              } else { // Manual mode always requires user approval
                  logger.warn('Manual approval required because "approvalMode" is set to "manual".');
                  notifyApprovalRequired(config.projectId, config.enableNotifications);
                  isApproved = await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
              }

              if (isApproved) {
                  stateFile.approved = true;
                  await writePendingState(cwd, stateFile); // Update state with approved: true before commit
                  await commitState(cwd, uuid);
                  logCompletionSummary(uuid, startTime, operations);
                  notifySuccess(uuid, config.enableNotifications);

                  if (config.autoGitBranch) {
                      let branchNameSegment = '';
                      if (config.gitBranchTemplate === 'gitCommitMsg' && stateFile.gitCommitMsg) {
                          branchNameSegment = stateFile.gitCommitMsg;
                      } else {
                          branchNameSegment = stateFile.uuid;
                      }
                  
                      const sanitizedSegment = branchNameSegment
                          .trim()
                          .toLowerCase()
                          .replace(/[^\w\s-]/g, '') // Remove all non-word, non-space, non-hyphen chars
                          .replace(/[\s_]+/g, '-') // Replace spaces and underscores with a single hyphen
                          .replace(/-+/g, '-') // Collapse consecutive hyphens
                          .replace(/^-|-$/g, '') // Trim leading/trailing hyphens
                          .slice(0, 70); // Truncate
                  
                      if (sanitizedSegment) {
                          const branchName = `${config.gitBranchPrefix}${sanitizedSegment}`;
                          logger.info(`Creating and switching to new git branch: ${chalk.magenta(branchName)}`);
      =======
              // Check for approval
              const finalErrorCount = await getErrorCount(config.patch.linter, cwd);
              logger.log(`  - Final linter error count: ${finalErrorCount > 0 ? chalk.red(finalErrorCount) : chalk.green(finalErrorCount)}`);
              
              let isApproved: boolean;
              if (config.patch.approvalMode === 'auto') { // Auto mode allows conditional auto-approval
                  const canAutoApprove = finalErrorCount <= config.patch.approvalOnErrorCount;

                  if (canAutoApprove) {
                      logger.success('  - Changes automatically approved based on your configuration.');
                      isApproved = true;
                  } else {
                      notifyApprovalRequired(config.projectId, config.core.enableNotifications);
                      isApproved = await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
                  }
              } else { // Manual mode always requires user approval
                  logger.warn('Manual approval required because "approvalMode" is set to "manual".');
                  notifyApprovalRequired(config.projectId, config.core.enableNotifications);
                  isApproved = await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
              }

              if (isApproved) {
                  stateFile.approved = true;
                  await writePendingState(cwd, stateFile); // Update state with approved: true before commit
                  await commitState(cwd, uuid);
                  logCompletionSummary(uuid, startTime, operations);
                  notifySuccess(uuid, config.core.enableNotifications);

                  if (config.git.autoGitBranch) {
                      let branchNameSegment = '';
                      if (config.git.gitBranchTemplate === 'gitCommitMsg' && stateFile.gitCommitMsg) {
                          branchNameSegment = stateFile.gitCommitMsg;
                      } else {
                          branchNameSegment = stateFile.uuid;
                      }
                  
                      const sanitizedSegment = branchNameSegment
                          .trim()
                          .toLowerCase()
                          .replace(/[^\w\s-]/g, '') // Remove all non-word, non-space, non-hyphen chars
                          .replace(/[\s_]+/g, '-') // Replace spaces and underscores with a single hyphen
                          .replace(/-+/g, '-') // Collapse consecutive hyphens
                          .replace(/^-|-$/g, '') // Trim leading/trailing hyphens
                          .slice(0, 70); // Truncate
                  
                      if (sanitizedSegment) {
                          const branchName = `${config.git.gitBranchPrefix}${sanitizedSegment}`;
                          logger.info(`Creating and switching to new git branch: ${chalk.magenta(branchName)}`);
      >>>>>>> REPLACE
      <<<<<<< SEARCH
                          const command = `git checkout -b "${branchName}"`;
                          const result = await executeShellCommand(command, cwd);
                          if (result.exitCode === 0) {
                              logger.success(`Successfully created and switched to branch '${chalk.magenta(branchName)}'.`);
                          } else {
                              logger.warn(`Could not create branch '${chalk.magenta(branchName)}'. It might already exist.`);
                              logger.debug(`'${command}' failed with: ${result.stderr}`);
                          }
                      } else {
                          logger.warn('Could not generate a branch name segment from commit message or UUID. Skipping git branch creation.');
                      }
                  }
              } else {
                  throw new Error('Changes were not approved.');
              }
          } catch (error) {
              const reason = getErrorMessage(error);
              await rollbackTransaction(cwd, uuid, snapshot, reason, config.enableNotifications);
          }
      };
      =======
                          const command = `git checkout -b "${branchName}"`;
                          const result = await executeShellCommand(command, cwd);
                          if (result.exitCode === 0) {
                              logger.success(`Successfully created and switched to branch '${chalk.magenta(branchName)}'.`);
                          } else {
                              logger.warn(`Could not create branch '${chalk.magenta(branchName)}'. It might already exist.`);
                              logger.debug(`'${command}' failed with: ${result.stderr}`);
                          }
                      } else {
                          logger.warn('Could not generate a branch name segment from commit message or UUID. Skipping git branch creation.');
                      }
                  }
              } else {
                  throw new Error('Changes were not approved.');
              }
          } catch (error) {
              const reason = getErrorMessage(error);
              await rollbackTransaction(cwd, uuid, snapshot, reason, config.core.enableNotifications);
          }
      };
      >>>>>>> REPLACE
    patchStrategy: multi-search-replace
snapshot:
  relaycode.config.json: |
    {
      "projectId": "relaycode",
      "logLevel": "info",
      "clipboardPollInterval": 2000,
      "approvalMode": "auto",
      "approvalOnErrorCount": 0,
      "linter": "bun tsc -b --noEmit",
      "preCommand": "",
      "postCommand": "",
      "preferredStrategy": "auto",
      "enableNotifications": true,
      "autoGitBranch": false,
      "gitBranchPrefix": "relay/",
      "gitBranchTemplate": "gitCommitMsg",
      "watchConfig": false
    }
  src/types.ts: >-
    import { z } from 'zod';


    export const LogLevelNameSchema = z.enum(['silent', 'error', 'warn', 'info',
    'debug']).default('info');

    export type LogLevelName = z.infer<typeof LogLevelNameSchema>;


    // Schema for relaycode.config.json

    export const ConfigSchema = z.object({
      projectId: z.string().min(1),
      logLevel: LogLevelNameSchema,
      clipboardPollInterval: z.number().int().positive().default(2000),
      approvalMode: z.enum(['auto', 'manual']).default('auto'),
      approvalOnErrorCount: z.number().int().min(0).default(0),
      linter: z.string().default('bun tsc --noEmit'),
      preCommand: z.string().default(''),
      postCommand: z.string().default(''),
      preferredStrategy: z.enum(['auto', 'replace', 'new-unified', 'multi-search-replace']).default('auto'),
      enableNotifications: z.boolean().default(true),
      autoGitBranch: z.boolean().default(false),
      gitBranchPrefix: z.string().default('relay/'),
      gitBranchTemplate: z.enum(['uuid', 'gitCommitMsg']).default('gitCommitMsg'),
      watchConfig: z.boolean().default(true),
    });

    export type Config = z.infer<typeof ConfigSchema>;


    export const PatchStrategySchema = z.enum([
      'replace',
      'new-unified',
      'multi-search-replace',
      'unified',
    ]).default('replace');

    export type PatchStrategy = z.infer<typeof PatchStrategySchema>;


    // Schema for operations parsed from code blocks

    export const FileOperationSchema = z.union([
      z.object({
        type: z.literal('write'),
        path: z.string(),
        content: z.string(),
        patchStrategy: PatchStrategySchema,
      }),
      z.object({
        type: z.literal('delete'),
        path: z.string(),
      }),
      z.object({
        type: z.literal('rename'),
        from: z.string(),
        to: z.string(),
      }),
    ]);

    export type FileOperation = z.infer<typeof FileOperationSchema>;


    // Schema for the control YAML block at the end of the LLM response

    export const ControlYamlSchema = z.object({
      projectId: z.string(),
      uuid: z.string().uuid(),
      changeSummary: z.array(z.record(z.string())).optional(), // Not strictly used, but good to parse
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
    });

    export type ControlYaml = z.infer<typeof ControlYamlSchema>;


    // The fully parsed response from the clipboard

    export const ParsedLLMResponseSchema = z.object({
      control: ControlYamlSchema,
      operations: z.array(FileOperationSchema),
      reasoning: z.array(z.string()),
    });

    export type ParsedLLMResponse = z.infer<typeof ParsedLLMResponseSchema>;


    // Schema for the snapshot of original files

    export const FileSnapshotSchema = z.record(z.string(),
    z.string().nullable()); // path -> content | null (if file didn't exist)

    export type FileSnapshot = z.infer<typeof FileSnapshotSchema>;


    // Schema for the state file (.relaycode/{uuid}.yml or .pending.yml)

    export const StateFileSchema = z.object({
      uuid: z.string().uuid(),
      projectId: z.string(),
      createdAt: z.string().datetime(),
      gitCommitMsg: z.string().optional(),
      promptSummary: z.string().optional(),
      reasoning: z.array(z.string()),
      operations: z.array(FileOperationSchema),
      snapshot: FileSnapshotSchema,
      approved: z.boolean(),
    });

    export type StateFile = z.infer<typeof StateFileSchema>;


    // Shell command execution result

    export const ShellCommandResultSchema = z.object({
        stdout: z.string(),
        stderr: z.string(),
        exitCode: z.number().nullable(),
    });

    export type ShellCommandResult = z.infer<typeof ShellCommandResultSchema>;
  src/core/config.ts: >-
    import { z } from 'zod';

    import path from 'path';

    import { promises as fs } from 'fs';

    import { Config, ConfigSchema } from '../types';

    import { CONFIG_FILE_NAME, STATE_DIRECTORY_NAME } from '../utils/constants';

    import { logger, isEnoentError } from '../utils/logger';

    import chalk from 'chalk';


    export const findConfig = async (cwd: string = process.cwd()):
    Promise<Config | null> => {
      const configPath = path.join(cwd, CONFIG_FILE_NAME);
      try {
        const fileContent = await fs.readFile(configPath, 'utf-8');
        const configJson = JSON.parse(fileContent);
        return ConfigSchema.parse(configJson);
      } catch (error) {
        if (isEnoentError(error)) {
          return null;
        }
        if (error instanceof z.ZodError) {
          throw new Error(`Invalid configuration in ${CONFIG_FILE_NAME}: ${error.message}`);
        }
        throw error;
      }
    };


    export const loadConfigOrExit = async (cwd: string = process.cwd()):
    Promise<Config> => {
        const config = await findConfig(cwd);
        if (!config) {
            logger.error(`Configuration file '${chalk.cyan(CONFIG_FILE_NAME)}' not found.`);
            logger.info(`Please run ${chalk.magenta("'relay init'")} to create one.`);
            process.exit(1);
        }
        return config;
    };


    export const createConfig = async (projectId: string, cwd: string =
    process.cwd()): Promise<Config> => {
        const config = {
            projectId,
            clipboardPollInterval: 2000,
            approvalMode: 'auto' as const,
            approvalOnErrorCount: 0,
            linter: 'bun tsc --noEmit',
            preCommand: '',
            postCommand: '',
            preferredStrategy: 'auto' as const,
            enableNotifications: true,
        };
        
        // Ensure the schema defaults are applied, including for logLevel
        const validatedConfig = ConfigSchema.parse(config);

        const configPath = path.join(cwd, CONFIG_FILE_NAME);
        await fs.writeFile(configPath, JSON.stringify(validatedConfig, null, 2));

        return validatedConfig;
    };


    export const ensureStateDirExists = async (cwd: string = process.cwd()):
    Promise<void> => {
        const stateDirPath = path.join(cwd, STATE_DIRECTORY_NAME);
        await fs.mkdir(stateDirPath, { recursive: true });
    };


    export const getProjectId = async (cwd: string = process.cwd()):
    Promise<string> => {
        try {
            const pkgJsonPath = path.join(cwd, 'package.json');
            const fileContent = await fs.readFile(pkgJsonPath, 'utf-8');
            const pkgJson = JSON.parse(fileContent);
            if (pkgJson.name && typeof pkgJson.name === 'string') {
                return pkgJson.name;
            }
        } catch (e) {
            // Ignore if package.json doesn't exist or is invalid
        }
        return path.basename(cwd);
    };
  src/commands/init.ts: >-
    import { promises as fs } from 'fs';

    import path from 'path';

    import { findConfig, createConfig, ensureStateDirExists, getProjectId } from
    '../core/config';

    import { logger, getErrorMessage, isEnoentError } from '../utils/logger';

    import { CONFIG_FILE_NAME, STATE_DIRECTORY_NAME, GITIGNORE_FILE_NAME,
    GITIGNORE_COMMENT } from '../utils/constants';

    import chalk from 'chalk';


    const getInitMessage = (projectId: string): string => `

    ${chalk.green('✅ relaycode has been initialized for this project.')}


    Configuration file created: ${chalk.cyan(CONFIG_FILE_NAME)}


    Project ID: ${chalk.cyan(projectId)}


    ${chalk.bold('Next steps:')}

    ${chalk.gray('1.')} (Optional) Open ${chalk.cyan(CONFIG_FILE_NAME)} to
    customize settings like ${chalk.yellow("'preferredStrategy'")} to control
    how the AI generates code patches.
       - ${chalk.yellow("'auto'")} (default): The AI can choose the best patch strategy.
       - ${chalk.yellow("'new-unified'")}: Forces the AI to use diffs, great for most changes.
       - ${chalk.yellow("'replace'")}: Forces the AI to replace entire files, good for new files or small changes.
       - ${chalk.yellow("'multi-search-replace'")}: Forces the AI to perform precise search and replace operations.
       - For Git users, enable ${chalk.yellow("'autoGitBranch'")} to create a new branch for each transaction.

    ${chalk.gray('2.')} Run ${chalk.magenta("'relay watch'")} in your terminal.
    This will start the service and display the system prompt tailored to your
    configuration.


    ${chalk.gray('3.')} Copy the system prompt provided by
    ${chalk.magenta("'relay watch'")} and paste it into your AI assistant's
    "System Prompt" or "Custom Instructions".

    `;



    const updateGitignore = async (cwd: string): Promise<void> => {
        const gitignorePath = path.join(cwd, GITIGNORE_FILE_NAME);
        const entry = `\n${GITIGNORE_COMMENT}\n/${STATE_DIRECTORY_NAME}/\n`;

        try {
            let content = await fs.readFile(gitignorePath, 'utf-8');
            if (!content.includes(STATE_DIRECTORY_NAME)) {
                content += entry;
                await fs.writeFile(gitignorePath, content);
                logger.info(`Updated ${chalk.cyan(GITIGNORE_FILE_NAME)} to ignore ${chalk.cyan(STATE_DIRECTORY_NAME)}/`);
            }
        } catch (error) {
            if (isEnoentError(error)) {
                await fs.writeFile(gitignorePath, entry.trim());
                logger.info(`Created ${chalk.cyan(GITIGNORE_FILE_NAME)} and added ${chalk.cyan(STATE_DIRECTORY_NAME)}/`);
            } else {
                logger.error(`Failed to update ${chalk.cyan(GITIGNORE_FILE_NAME)}: ${getErrorMessage(error)}`);
            }
        }
    };


    export const initCommand = async (cwd: string = process.cwd()):
    Promise<void> => {
        logger.info('Initializing relaycode in this project...');

        const config = await findConfig(cwd);
        if (config) {
            logger.warn(`${chalk.cyan(CONFIG_FILE_NAME)} already exists. Initialization skipped.`);
            logger.log(`
    To use relaycode, please run ${chalk.magenta("'relay watch'")}.

    It will display a system prompt to copy into your LLM assistant.

    You can review your configuration in ${chalk.cyan(CONFIG_FILE_NAME)}.

    `);
            return;
        }
        
        const projectId = await getProjectId(cwd);
        await createConfig(projectId, cwd);
        logger.success(`Created configuration file: ${CONFIG_FILE_NAME}`);
        
        await ensureStateDirExists(cwd);
        logger.success(`Created state directory: ${STATE_DIRECTORY_NAME}/`);

        await updateGitignore(cwd);

        logger.log(getInitMessage(projectId));
    };
  src/commands/apply.ts: >-
    import { promises as fs } from 'fs';

    import path from 'path';

    import { loadConfigOrExit } from '../core/config';

    import { parseLLMResponse } from '../core/parser';

    import { processPatch } from '../core/transaction';

    import { logger } from '../utils/logger';

    import chalk from 'chalk';


    export const applyCommand = async (filePath: string, cwd: string =
    process.cwd()): Promise<void> => {
        const config = await loadConfigOrExit(cwd);
        logger.setLevel(config.logLevel);

        let content: string;
        const absoluteFilePath = path.resolve(cwd, filePath);
        try {
            content = await fs.readFile(absoluteFilePath, 'utf-8');
            logger.info(`Reading patch from file: ${chalk.cyan(absoluteFilePath)}`);
        } catch (error) {
            logger.error(`Failed to read patch file at '${chalk.cyan(absoluteFilePath)}'. Aborting.`);
            return;
        }

        logger.info('Attempting to parse patch file...');
        const parsedResponse = parseLLMResponse(content);

        if (!parsedResponse) {
            logger.error('The content of the file is not a valid relaycode patch. Aborting.');
            return;
        }

        logger.success('Valid patch format detected. Processing...');
        await processPatch(config, parsedResponse, { cwd });
        logger.info(chalk.gray('--------------------------------------------------'));
    };
  src/commands/watch.ts: >-
    import { findConfig, loadConfigOrExit } from '../core/config';

    import { createClipboardWatcher } from '../core/clipboard';

    import { parseLLMResponse } from '../core/parser';

    import { processPatch } from '../core/transaction';

    import { logger } from '../utils/logger';

    import { CONFIG_FILE_NAME } from '../utils/constants'

    import { Config } from '../types';

    import fs from 'fs';

    import path from 'path';


    const getSystemPrompt = (projectId: string, preferredStrategy:
    Config['preferredStrategy']): string => {
        const header = `
    ✅ relaycode is watching for changes.


    IMPORTANT: For relaycode to work, you must configure your AI assistant.

    Copy the entire text below and paste it into your LLM's "System Prompt"

    or "Custom Instructions" section.

    ---------------------------------------------------------------------------`;

        const intro = `You are an expert AI programmer. To modify a file, you MUST use a code block with a specified patch strategy.`;

        const syntaxAuto = `
    **Syntax:**

    \`\`\`typescript // filePath {patchStrategy}

    ... content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - \`patchStrategy\`: (Optional) One of \`new-unified\`,
    \`multi-search-replace\`. If omitted, the entire file is replaced (this is
    the \`replace\` strategy).


    **Examples:**

    \`\`\`typescript // src/components/Button.tsx

    ...

    \`\`\`

    \`\`\`typescript // "src/components/My Component.tsx" new-unified

    ...

    \`\`\``;

        const syntaxReplace = `
    **Syntax:**

    \`\`\`typescript // filePath

    ... content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - Only the \`replace\` strategy is enabled. This means you must provide the
    ENTIRE file content for any change. This is suitable for creating new files
    or making changes to small files.`;

        const syntaxNewUnified = `
    **Syntax:**

    \`\`\`typescript // filePath new-unified

    ... diff content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - You must use the \`new-unified\` patch strategy for all modifications.`;

        const syntaxMultiSearchReplace = `
    **Syntax:**

    \`\`\`typescript // filePath multi-search-replace

    ... diff content ...

    \`\`\`

    - \`filePath\`: The path to the file. **If the path contains spaces, it MUST
    be enclosed in double quotes.**

    - You must use the \`multi-search-replace\` patch strategy for all
    modifications.`;

        const sectionNewUnified = `---

    ### Strategy 1: Advanced Unified Diff (\`new-unified\`) - RECOMMENDED


    Use for most changes, like refactoring, adding features, and fixing bugs.
    It's resilient to minor changes in the source file.


    **Diff Format:**

    1.  **File Headers**: Start with \`--- {filePath}\` and \`+++ {filePath}\`.

    2.  **Hunk Header**: Use \`@@ ... @@\`. Exact line numbers are not needed.

    3.  **Context Lines**: Include 2-3 unchanged lines before and after your
    change for context.

    4.  **Changes**: Mark additions with \`+\` and removals with \`-\`. Maintain
    indentation.


    **Example:**

    \`\`\`diff

    --- src/utils.ts

    +++ src/utils.ts

    @@ ... @@
        function calculateTotal(items: number[]): number {
    -      return items.reduce((sum, item) => {

    -        return sum + item;

    -      }, 0);

    +      const total = items.reduce((sum, item) => {

    +        return sum + item * 1.1;  // Add 10% markup

    +      }, 0);

    +      return Math.round(total * 100) / 100;  // Round to 2 decimal places

    +    }

    \`\`\`

    `;

        const sectionMultiSearchReplace = `---

    ### Strategy 2: Multi-Search-Replace (\`multi-search-replace\`)


    Use for precise, surgical replacements. The \`SEARCH\` block must be an
    exact match of the content in the file.


    **Diff Format:**

    Repeat this block for each replacement.

    \`\`\`diff

    <<<<<<< SEARCH

    [new content to replace with]

    =======

    [new content to replace with]

    >>>>>>> REPLACE

    \`\`\`

    `;

        const otherOps = `---

    ### Other Operations


    -   **Creating a file**: Use the default \`replace\` strategy (omit the
    strategy name) and provide the full file content.

    -   **Deleting a file**:
        \`\`\`typescript // path/to/file.ts
        //TODO: delete this file
        \`\`\`
        \`\`\`typescript // "path/to/My Old Component.ts"
        //TODO: delete this file
        \`\`\`
    -   **Renaming/Moving a file**:
        \`\`\`json // rename-file
        {
          "from": "src/old/path/to/file.ts",
          "to": "src/new/path/to/file.ts"
        }
        \`\`\`
    `;

        const finalSteps = `---

    ### Final Steps


    1.  Add your step-by-step reasoning in plain text before each code block.

    2.  ALWAYS add the following YAML block at the very end of your response.
    Use the exact projectId shown here. Generate a new random uuid for each
    response.

        \`\`\`yaml
        projectId: ${projectId}
        uuid: (generate a random uuid)
        changeSummary:
          - edit: src/main.ts
          - new: src/components/Button.tsx
          - delete: src/utils/old-helper.ts
        promptSummary: "A brief summary of my request."
        gitCommitMsg: "feat: A concise, imperative git commit message."
        \`\`\`
    `;
        
        const footer = `---------------------------------------------------------------------------`;

        const syntaxMap = {
            auto: syntaxAuto,
            replace: syntaxReplace,
            'new-unified': syntaxNewUnified,
            'multi-search-replace': syntaxMultiSearchReplace,
        };

        const strategyDetailsMap = {
            auto: `${sectionNewUnified}\n${sectionMultiSearchReplace}`,
            replace: '', // Covered in 'otherOps'
            'new-unified': sectionNewUnified,
            'multi-search-replace': sectionMultiSearchReplace,
        };

        const syntax = syntaxMap[preferredStrategy] ?? syntaxMap.auto;
        const strategyDetails = strategyDetailsMap[preferredStrategy] ?? strategyDetailsMap.auto;

        return [header, intro, syntax, strategyDetails, otherOps, finalSteps, footer].filter(Boolean).join('\n');
    }


    export const watchCommand = async (cwd: string = process.cwd()): Promise<{
    stop: () => void }> => {
      let clipboardWatcher: ReturnType<typeof createClipboardWatcher> | null = null;
      const configPath = path.resolve(cwd, CONFIG_FILE_NAME);
      let configWatcher: fs.FSWatcher | null = null;
      let debounceTimer: NodeJS.Timeout | null = null;

      const startServices = (config: Config) => {
        // Stop existing watcher if it's running
        if (clipboardWatcher) {
          clipboardWatcher.stop();
        }

        logger.setLevel(config.logLevel);
        logger.debug(`Log level set to: ${config.logLevel}`);
        logger.debug(`Preferred strategy set to: ${config.preferredStrategy}`);

        logger.log(getSystemPrompt(config.projectId, config.preferredStrategy));

        clipboardWatcher = createClipboardWatcher(config.clipboardPollInterval, async (content) => {
          logger.info('New clipboard content detected. Attempting to parse...');
          const parsedResponse = parseLLMResponse(content);

          if (!parsedResponse) {
            logger.warn('Clipboard content is not a valid relaycode patch. Ignoring.');
            return;
          }

          // Check project ID before notifying and processing.
          if (parsedResponse.control.projectId !== config.projectId) {
            logger.debug(`Ignoring patch for different project (expected '${config.projectId}', got '${parsedResponse.control.projectId}').`);
            return;
          }

          await processPatch(config, parsedResponse, { cwd, notifyOnStart: true });
          logger.info('--------------------------------------------------');
          logger.info('Watching for next patch...');
        });
      };

      const handleConfigChange = () => {
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
          logger.info(`Configuration file change detected. Reloading...`);
          try {
            const newConfig = await findConfig(cwd);
            if (newConfig) {
              logger.success('Configuration reloaded. Restarting services...');
              startServices(newConfig);
            } else {
              logger.error(`${CONFIG_FILE_NAME} is invalid or has been deleted. Services paused.`);
              if (clipboardWatcher) {
                clipboardWatcher.stop();
                clipboardWatcher = null;
              }
            }
          } catch (error) {
            logger.error(`Error reloading configuration: ${error instanceof Error ? error.message : String(error)}`);
          }
        }, 250);
      };

      // Initial startup
      const initialConfig = await loadConfigOrExit(cwd);
      logger.success('Configuration loaded. Starting relaycode watch...');
      startServices(initialConfig);

      // Watch for changes after initial setup
      if (initialConfig.watchConfig) {
        logger.info('Configuration file watching is enabled.');
        configWatcher = fs.watch(configPath, handleConfigChange);
      } else {
        logger.info('Configuration file watching is disabled. Changes to config will require a restart to take effect.');
      }

      const stopAll = () => {
        if (clipboardWatcher) {
          clipboardWatcher.stop();
        }
        if (configWatcher) {
          configWatcher.close();
          logger.info('Configuration file watcher stopped.');
        }
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
      };
      return { stop: stopAll };
    };
  src/core/transaction.ts: >-
    import { Config, ParsedLLMResponse, StateFile, FileSnapshot, FileOperation }
    from '../types';

    import { logger, getErrorMessage } from '../utils/logger';

    import { getErrorCount, executeShellCommand } from '../utils/shell';

    import { createSnapshot, restoreSnapshot, applyOperations } from
    './executor';

    import chalk from 'chalk';

    import { hasBeenProcessed, writePendingState, commitState,
    deletePendingState } from './state';

    import { getConfirmation } from '../utils/prompt'

    import { notifyApprovalRequired, notifyFailure, notifySuccess,
    notifyPatchDetected } from '../utils/notifier';


    type Prompter = (question: string) => Promise<boolean>;


    type ProcessPatchOptions = {
        prompter?: Prompter;
        cwd?: string;
        notifyOnStart?: boolean;
    };


    const calculateLineChanges = (
        op: FileOperation,
        snapshot: FileSnapshot,
        newContents: Map<string, string>
    ): { added: number; removed: number } => {
        if (op.type === 'rename') {
            return { added: 0, removed: 0 };
        }
        const oldContent = snapshot[op.path] ?? null;

        if (op.type === 'delete') {
            const oldLines = oldContent ? oldContent.split('\n') : [];
            return { added: 0, removed: oldLines.length };
        }
        
        const newContent = newContents.get(op.path) ?? null;

        if (oldContent === newContent) return { added: 0, removed: 0 };

        const oldLines = oldContent?.split('\n') ?? [];
        const newLines = newContent?.split('\n') ?? [];

        if (oldContent === null || oldContent === '') return { added: newLines.length, removed: 0 };
        if (newContent === null || newContent === '') return { added: 0, removed: oldLines.length };
        
        // This is a simplified diff, for a more accurate count a real diff algorithm is needed,
        // but this is fast and good enough for a summary.
        const oldSet = new Set(oldLines);
        const newSet = new Set(newLines);
        
        let added = 0;
        for (const line of newLines) {
            if (!oldSet.has(line)) added++;
        }

        let removed = 0;
        for (const line of oldLines) {
            if (!newSet.has(line)) removed++;
        }
        
        return { added, removed };
    };


    const logCompletionSummary = (
        uuid: string,
        startTime: number,
        operations: FileOperation[]
    ) => {
        const duration = performance.now() - startTime;

        logger.log(chalk.bold('\nSummary:'));
        logger.log(`Applied ${chalk.cyan(operations.length)} file operation(s) successfully.`);
        logger.log(`Total time from start to commit: ${chalk.gray(`${duration.toFixed(2)}ms`)}`);
        logger.success(`✅ Transaction ${chalk.gray(uuid)} committed successfully!`);
    };


    const rollbackTransaction = async (cwd: string, uuid: string, snapshot:
    FileSnapshot, reason: string, enableNotifications: boolean = true):
    Promise<void> => {
        logger.warn(`Rolling back changes: ${reason}`);
        try {
            await restoreSnapshot(snapshot, cwd);
            logger.success('  - Files restored to original state.');
        } catch (error) {
            logger.error(`Fatal: Rollback failed: ${getErrorMessage(error)}`);
            // Do not rethrow; we're already in a final error handling state.
        } finally {
            try {
                await deletePendingState(cwd, uuid);
                logger.success(`↩️ Transaction ${chalk.gray(uuid)} rolled back.`);
                notifyFailure(uuid, enableNotifications);
            } catch (cleanupError) {
                logger.error(`Fatal: Could not clean up pending state for ${chalk.gray(uuid)}: ${getErrorMessage(cleanupError)}`);
            }
        }
    };


    export const processPatch = async (config: Config, parsedResponse:
    ParsedLLMResponse, options?: ProcessPatchOptions): Promise<void> => {
        const cwd = options?.cwd || process.cwd();
        const prompter = options?.prompter || getConfirmation;
        const notifyOnStart = options?.notifyOnStart ?? false;
        const { control, operations, reasoning } = parsedResponse;
        const { uuid, projectId } = control;
        const startTime = performance.now();

        // 1. Validation
        if (projectId !== config.projectId) {
            logger.warn(`Skipping patch: projectId mismatch (expected '${chalk.cyan(config.projectId)}', got '${chalk.cyan(projectId)}').`);
            return;
        }
        if (await hasBeenProcessed(cwd, uuid)) {
            logger.info(`Skipping patch: uuid '${chalk.gray(uuid)}' has already been processed.`);
            return;
        }

        // Notify if coming from watch mode, now that we know it's a new patch.
        if (notifyOnStart) {
            notifyPatchDetected(config.projectId, config.enableNotifications);
            logger.success(`Valid patch detected for project '${chalk.cyan(config.projectId)}'. Processing...`);
        }

        // 2. Pre-flight checks
        if (config.preCommand) {
            logger.log(`  - Running pre-command: ${chalk.magenta(config.preCommand)}`);
            const { exitCode, stderr } = await executeShellCommand(config.preCommand, cwd);
            if (exitCode !== 0) {
                logger.error(`Pre-command failed with exit code ${chalk.red(exitCode)}, aborting transaction.`);
                if (stderr) logger.error(`Stderr: ${stderr}`);
                return;
            }
        }

        logger.info(`🚀 Starting transaction for patch ${chalk.gray(uuid)}...`);
        logger.log(`${chalk.bold('Reasoning:')}\n  ${reasoning.join('\n  ')}`);

        const affectedFilePaths = operations.reduce<string[]>((acc, op) => {
            if (op.type === 'rename') {
                acc.push(op.from, op.to);
            } else {
                acc.push(op.path);
            }
            return acc;
        }, []);
        const snapshot = await createSnapshot(affectedFilePaths, cwd);
        
        const stateFile: StateFile = {
            uuid,
            projectId,
            createdAt: new Date().toISOString(),
            gitCommitMsg: control.gitCommitMsg,
            promptSummary: control.promptSummary,
            reasoning,
            operations,
            snapshot,
            approved: false,
        };

        try {
            await writePendingState(cwd, stateFile);
            logger.success('  - Staged changes to .pending.yml file.');

            // Apply changes
            logger.log('  - Applying file operations...');
            const newContents = await applyOperations(operations, cwd);
            logger.success('  - File operations complete.');

            const opStats = operations.map(op => {
                const stats = calculateLineChanges(op, snapshot, newContents);
                if (op.type === 'write') {
                    logger.success(`✔ Written: ${chalk.cyan(op.path)} (${chalk.green(`+${stats.added}`)}, ${chalk.red(`-${stats.removed}`)})`);
                } else if (op.type === 'delete') {
                    logger.success(`✔ Deleted: ${chalk.cyan(op.path)}`);
                } else if (op.type === 'rename') {
                    logger.success(`✔ Renamed: ${chalk.cyan(op.from)} -> ${chalk.cyan(op.to)}`);
                }
                return stats;
            });

            // Run post-command
            if (config.postCommand) {
                logger.log(`  - Running post-command: ${chalk.magenta(config.postCommand)}`);
                const postResult = await executeShellCommand(config.postCommand, cwd);
                if (postResult.exitCode !== 0) {
                    logger.error(`Post-command failed with exit code ${chalk.red(postResult.exitCode)}.`);
                    if (postResult.stderr) logger.error(`Stderr: ${postResult.stderr}`);
                    throw new Error('Post-command failed, forcing rollback.');
                }
            }

            // Log summary before asking for approval
            const checksDuration = performance.now() - startTime;
            const totalAdded = opStats.reduce((sum, s) => sum + s.added, 0);
            const totalRemoved = opStats.reduce((sum, s) => sum + s.removed, 0);

            logger.log(chalk.bold('\nPre-flight summary:'));
            logger.success(`Lines changed: ${chalk.green(`+${totalAdded}`)}, ${chalk.red(`-${totalRemoved}`)}`);
            logger.log(`Checks completed in ${chalk.gray(`${checksDuration.toFixed(2)}ms`)}`);

            // Check for approval
            const finalErrorCount = await getErrorCount(config.linter, cwd);
            logger.log(`  - Final linter error count: ${finalErrorCount > 0 ? chalk.red(finalErrorCount) : chalk.green(finalErrorCount)}`);
            
            let isApproved: boolean;
            if (config.approvalMode === 'auto') { // Auto mode allows conditional auto-approval
                const canAutoApprove = finalErrorCount <= config.approvalOnErrorCount;

                if (canAutoApprove) {
                    logger.success('  - Changes automatically approved based on your configuration.');
                    isApproved = true;
                } else {
                    notifyApprovalRequired(config.projectId, config.enableNotifications);
                    isApproved = await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
                }
            } else { // Manual mode always requires user approval
                logger.warn('Manual approval required because "approvalMode" is set to "manual".');
                notifyApprovalRequired(config.projectId, config.enableNotifications);
                isApproved = await prompter('Changes applied. Do you want to approve and commit them? (y/N)');
            }

            if (isApproved) {
                stateFile.approved = true;
                await writePendingState(cwd, stateFile); // Update state with approved: true before commit
                await commitState(cwd, uuid);
                logCompletionSummary(uuid, startTime, operations);
                notifySuccess(uuid, config.enableNotifications);

                if (config.autoGitBranch) {
                    let branchNameSegment = '';
                    if (config.gitBranchTemplate === 'gitCommitMsg' && stateFile.gitCommitMsg) {
                        branchNameSegment = stateFile.gitCommitMsg;
                    } else {
                        branchNameSegment = stateFile.uuid;
                    }
                
                    const sanitizedSegment = branchNameSegment
                        .trim()
                        .toLowerCase()
                        .replace(/[^\w\s-]/g, '') // Remove all non-word, non-space, non-hyphen chars
                        .replace(/[\s_]+/g, '-') // Replace spaces and underscores with a single hyphen
                        .replace(/-+/g, '-') // Collapse consecutive hyphens
                        .replace(/^-|-$/g, '') // Trim leading/trailing hyphens
                        .slice(0, 70); // Truncate
                
                    if (sanitizedSegment) {
                        const branchName = `${config.gitBranchPrefix}${sanitizedSegment}`;
                        logger.info(`Creating and switching to new git branch: ${chalk.magenta(branchName)}`);
                        const command = `git checkout -b "${branchName}"`;
                        const result = await executeShellCommand(command, cwd);
                        if (result.exitCode === 0) {
                            logger.success(`Successfully created and switched to branch '${chalk.magenta(branchName)}'.`);
                        } else {
                            logger.warn(`Could not create branch '${chalk.magenta(branchName)}'. It might already exist.`);
                            logger.debug(`'${command}' failed with: ${result.stderr}`);
                        }
                    } else {
                        logger.warn('Could not generate a branch name segment from commit message or UUID. Skipping git branch creation.');
                    }
                }
            } else {
                throw new Error('Changes were not approved.');
            }
        } catch (error) {
            const reason = getErrorMessage(error);
            await rollbackTransaction(cwd, uuid, snapshot, reason, config.enableNotifications);
        }
    };
approved: true
